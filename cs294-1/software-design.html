<html xmlns:o="urn:schemas-microsoft-com:office:office"xmlns:w="urn:schemas-microsoft-com:office:word"xmlns="http://www.w3.org/TR/REC-html40"><head><meta name=Title content="Software Design: Theoretical Approaches"><meta name=Keywords content=""><meta http-equiv=Content-Type content="text/html; charset=windows-1252"><meta name=ProgId content=Word.Document><meta name=Generator content="Microsoft Word 10"><meta name=Originator content="Microsoft Word 10"><link rel=File-List href="Software%20Design_files/filelist.xml"><title>Software Design: Theoretical Approaches</title><!--[if gte mso 9]><xml> <o:DocumentProperties>  <o:Template>Normal</o:Template>  <o:LastAuthor>Andrew Begel</o:LastAuthor>  <o:Revision>3</o:Revision>  <o:Created>2002-02-06T08:56:00Z</o:Created>  <o:LastSaved>2002-02-06T08:57:00Z</o:LastSaved>  <o:Pages>1</o:Pages>  <o:Words>542</o:Words>  <o:Characters>3090</o:Characters>  <o:Company>Moo Cow</o:Company>  <o:Lines>25</o:Lines>  <o:Paragraphs>6</o:Paragraphs>  <o:CharactersWithSpaces>3794</o:CharactersWithSpaces>  <o:Version>10.1316</o:Version> </o:DocumentProperties> <o:OfficeDocumentSettings>  <o:DownloadComponents>96</o:DownloadComponents> </o:OfficeDocumentSettings></xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument>  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>  <w:UseMarginsForDrawingGridOrigin/>  <w:Compatibility>   <w:SpaceForUL/>   <w:BalanceSingleByteDoubleByteWidth/>   <w:DoNotLeaveBackslashAlone/>   <w:ULTrailSpace/>   <w:DoNotExpandShiftReturn/>   <w:AdjustLineHeightInTable/>  </w:Compatibility> </w:WordDocument></xml><![endif]--><style><!-- /* Style Definitions */p.MsoNormal, li.MsoNormal, div.MsoNormal	{mso-style-parent:"";	margin:0in;	margin-bottom:.0001pt;	mso-pagination:widow-orphan;	font-size:12.0pt;	font-family:Times;}p.MsoBodyText, li.MsoBodyText, div.MsoBodyText	{margin-top:0in;	margin-right:0in;	margin-bottom:6.0pt;	margin-left:0in;	mso-pagination:widow-orphan;	font-size:12.0pt;	font-family:Times;}p.MsoBodyTextFirstIndent, li.MsoBodyTextFirstIndent, div.MsoBodyTextFirstIndent	{mso-style-parent:"Body Text";	margin-top:0in;	margin-right:0in;	margin-bottom:6.0pt;	margin-left:0in;	text-indent:10.5pt;	mso-pagination:widow-orphan;	font-size:12.0pt;	font-family:Times;}@page Section1	{size:8.5in 11.0in;	margin:1.0in 1.25in 1.0in 1.25in;	mso-header-margin:.5in;	mso-footer-margin:.5in;	mso-paper-source:0;}div.Section1	{page:Section1;}--></style></head><body bgcolor=white lang=EN-US style='tab-interval:.5in'><div class=Section1><p class=MsoNormal>Andrew Begel</p><p class=MsoNormal>CS294-1</p><p class=MsoNormal>Software Design: Theoretical Approaches Review</p><p class=MsoNormal>February 6, 2002</p><p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p><p class=MsoBodyTextFirstIndent>Detienne’s book chapter 3 presents a survey ofcognitive psychology approaches to programming. This field posits that it’spossible to model the human brain as a set of data structures and algorithms,and that to understand how we perform certain tasks, we can observe peopleengaged in activities that make up the tasks. Much can be discerned fromexaminations of novices, experts and especially of the learning process wherebya novice turns into an expert. In the programming task, there appear to beseveral main organizing principles. </p><p class=MsoBodyTextFirstIndent>One, at a low-level, people record <i>schemas</i><spanstyle='font-style:normal'>, data structures that codify a process or a solutionto a problem. Schemas are modeled as maps of name-value pairs, where each slotcorresponds to some aspect of the problem, the knowledge of when to apply thesolution, and the solution itself. </span></p><p class=MsoBodyTextFirstIndent>In order to use schemas, humans utilize thesecond organizing principle, <i>strategies</i><span style='font-style:normal'>.In programming, problems are generally solved either top-down, bottom-up orusing a combination of the two approaches. In addition, programmers simulatebehaviors in their head to gain an understanding of the pros and cons of aparticular strategy before they employ it. People seem to have schemas thathelp them choose a strategy to use to solve a problem. Often, merely framing aproblem in a particular way triggers a strategy that might help in solving it.A successful schema employs a programmer’s knowledge of his tools to frame theproblem. This usually skews the solution towards one that can be solved withthose tools. This is known as the principle of the path of least resistance. </span></p><p class=MsoBodyTextFirstIndent>Finally, the third organizing principle isorganization itself. While hierarchical problem solving is taught in school,apparently the real organization skills that a programmer employs is much morecomplex and opportunistic. Programmers jump around to different abstractionlevels and solve pieces of the problem that seem most appropriate at the time.This can be linked to limited short-term memory. A programmer might just losetrack of where they were in solving the problem, and just continue from wherethey happen to end up instead of from where they were. </p><p class=MsoBodyTextFirstIndent>It’s important to understand how people learnto program, in order to improve the educational process. How does an expertorganize his knowledge differently from a novice? How is an expert’s processdifferent? Experts appear to have a library of schemas and strategies in theirhead. In addition, they have strategies for mutating schemas to work with newsituations. </p><p class=MsoBodyTextFirstIndent>Once we have a good understanding of howexperts think about problems, is there a way to use computer technology toaugment the formation of these processes in novices? For example, you couldcreate a database of schemas, suitably indexed, that a novice could use whentrying to figure out how to solve a particular problem (Clancy tried enablingnovices to enter and retrieve schemes in a Berkeley CS class, and found thatnovices’ lack of expertise in indexing schemas stymied their ability toretrieve them). Case studies are an attempt to lead novices through examples ofproblem-solving process schemas. Some of the work done on prototyping in theHCI community is attempting to apply these techniques to the design of websites (a particularly difficult piece of design to “get right” considering it’sa relatively young field). </p><p class=MsoBodyTextFirstIndent>Detienne does a good job surveying theliterature, but it feels like she left out work done in the 80s relating to automatedtutors, and debugging tools, as well as other approaches to the cognitivepsychology of program design such as Linn’s knowledge integration. </p></div></body></html>