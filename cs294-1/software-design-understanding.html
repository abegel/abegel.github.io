<html xmlns:o="urn:schemas-microsoft-com:office:office"xmlns:w="urn:schemas-microsoft-com:office:word"xmlns="http://www.w3.org/TR/REC-html40"><head><meta name=Title content="Andrew Begel"><meta name=Keywords content=""><meta http-equiv=Content-Type content="text/html; charset=windows-1252"><meta name=ProgId content=Word.Document><meta name=Generator content="Microsoft Word 10"><meta name=Originator content="Microsoft Word 10"><link rel=File-List href="Software%20Design-Understan_files/filelist.xml"><title>Andrew Begel</title><!--[if gte mso 9]><xml> <o:DocumentProperties>  <o:Template>Normal</o:Template>  <o:LastAuthor>Andrew Begel</o:LastAuthor>  <o:Revision>3</o:Revision>  <o:Created>2002-02-11T08:34:00Z</o:Created>  <o:LastSaved>2002-02-11T08:36:00Z</o:LastSaved>  <o:Pages>2</o:Pages>  <o:Words>682</o:Words>  <o:Characters>3889</o:Characters>  <o:Company>Moo Cow</o:Company>  <o:Lines>32</o:Lines>  <o:Paragraphs>7</o:Paragraphs>  <o:CharactersWithSpaces>4775</o:CharactersWithSpaces>  <o:Version>10.1316</o:Version> </o:DocumentProperties> <o:OfficeDocumentSettings>  <o:DownloadComponents>96</o:DownloadComponents> </o:OfficeDocumentSettings></xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument>  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>  <w:DisplayVerticalDrawingGridEvery>0</w:DisplayVerticalDrawingGridEvery>  <w:UseMarginsForDrawingGridOrigin/>  <w:Compatibility>   <w:SpaceForUL/>   <w:BalanceSingleByteDoubleByteWidth/>   <w:DoNotLeaveBackslashAlone/>   <w:ULTrailSpace/>   <w:DoNotExpandShiftReturn/>   <w:AdjustLineHeightInTable/>  </w:Compatibility> </w:WordDocument></xml><![endif]--><style><!-- /* Style Definitions */p.MsoNormal, li.MsoNormal, div.MsoNormal	{mso-style-parent:"";	margin:0in;	margin-bottom:.0001pt;	mso-pagination:widow-orphan;	font-size:12.0pt;	font-family:Times;}p.MsoBodyText, li.MsoBodyText, div.MsoBodyText	{margin-top:0in;	margin-right:0in;	margin-bottom:6.0pt;	margin-left:0in;	mso-pagination:widow-orphan;	font-size:12.0pt;	font-family:Times;}p.MsoBodyTextFirstIndent, li.MsoBodyTextFirstIndent, div.MsoBodyTextFirstIndent	{mso-style-parent:"Body Text";	margin-top:0in;	margin-right:0in;	margin-bottom:6.0pt;	margin-left:0in;	text-indent:10.5pt;	mso-pagination:widow-orphan;	font-size:12.0pt;	font-family:Times;}@page Section1	{size:8.5in 11.0in;	margin:1.0in 1.25in 1.0in 1.25in;	mso-header-margin:.5in;	mso-footer-margin:.5in;	mso-paper-source:0;}div.Section1	{page:Section1;}--></style></head><body bgcolor=white lang=EN-US style='tab-interval:.5in'><div class=Section1><p class=MsoNormal><span style='font-size:14.0pt'>Andrew Begel<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:14.0pt'>CS294-1<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:14.0pt'>Software Design:Understanding Software<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:14.0pt'>February 10, 2002<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:14.0pt'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p><p class=MsoBodyTextFirstIndent><span style='font-size:14.0pt'>I read thischapter twice. And I’m still not sure I fully get what’s being described here.My background in cognitive psychology is a bit lacking, so I’ll just summarizehere what I’ve read, and evaluate it after the (hopefully illuminating)discussion in class. <o:p></o:p></span></p><p class=MsoBodyTextFirstIndent><span style='font-size:14.0pt'>The premise ofthis chapter is to understand how programmers comprehend software. There arethree main models: functional, structural, and mental model, each derived fromprior research in text understanding. The functional model is top-down,schema-driven. As one reads a program, one matches the patterns to schemas, usingprogram structure and variables (and variable names) as beacons, or triggersfor the activation of schemas already present in the brain. From Detienne’sexperimental results, it feels that while this may be good for a generaltheory, it requires the person to know many many unique schemas to work.Soloway and Ehrlich showed that if you deliberately screwed up theinstantiation of the schemas in code, the experts (who were more invested inthe schemas than novices) would have more trouble understanding the programsthan novices. This feels to me like a reification of the programmer idea ofprogram “elegance.” An elegant program fits a lot of schemas, while a novice’sinelegant program screams out with violations. Detienne’s work on recall makesme recall Sachs’ work on sentence understanding. Sachs showed that humans don’tremember exact details of things they read/hear. They instead remember gists,or chunks. When asked to recall something, humans will get the gists right, butwill invent details to fit the gist, rather than remember the details of theoriginal. Detienne’s work showed that programmers remember programs better whenthey fit into the chunks of knowledge that they already have. They still,however, fill in details that were different from the original. <o:p></o:p></span></p><p class=MsoBodyTextFirstIndent><span style='font-size:14.0pt'>Thepropositional and structural approaches to program understanding utilize ahierarchical breakdown of a program, from control flow to variables. Moreover,this hierarchical breakdown mimics the form of structural programming, thus ifprogrammers really created programs this way, then the model would beexceedingly applicable. The propositional approach uses a network of logicalinferences for its implementation, while the structural model defines structurecloser to terms of program structure (functional, procedure, OO, etc). I don’tfully understand what Detienne is talking about when summarizing the work ofAtwood and Ramsey, and Vessey re: identifying errors in the propositional logicmodel. Code segmentation seems to be a way of categorizing various knowledgeschemas. Smalltalk’s (Squeak’s) code browser reifies this and enables theprogrammer to categories methods within a class (Smalltalk calls theseprotocols. In Java, they would be reified as Interfaces). Detienne finallyconcludes that there hasn’t been much work in this whole area and says that itwould be a ripe area for future research. Perhaps. But she doesn’t sound tooenthusiastic about it for some reason.<o:p></o:p></span></p><p class=MsoBodyTextFirstIndent><span style='font-size:14.0pt'>Pennington’smodel of comprehension is the mental model, a bottom-up internal representationof the program that considers the problem goals and data flow. This modelobviously requires some analysis of code since most programs are organized viacontrol flow rather than data flow. Detienne says that Pennington’s approachwon’t work for OO programs because it doesn’t recognize delocalized plans norwas it intended to apply to interprocedural flow, just intraprocedural.Burkhardt seems to have updated Pennington’s theories with information aboutthe data structures and the interprocedural relationships to create a morecomplete theory. It feels like there’s two theories here, one for inside aprocedure and one to represent the control flow of the entire program. I wouldbet this is hierarchical in really large programs, which is why we like to makeUML diagrams and refine them to greater and greater detail. Pennington andBurkhardt’s work seems to be experimentally verified. However, the experimentsin program comprehension here also used program modification as a means totrigger the construction of the situational framework. <o:p></o:p></span></p><p class=MsoBodyTextFirstIndent><span style='font-size:14.0pt'>I think morework should go into seeing the effects of manipulating a program on programunderstanding. Also, I’d like to see work in program expression, howprogrammers talk about the programs they’re building or understanding. I thinkthis can show a lot about how they have the program organized in their brain aswell as illuminate what it takes to pedagogically explain the content andmeaning of a program to others. <o:p></o:p></span></p></div></body></html>